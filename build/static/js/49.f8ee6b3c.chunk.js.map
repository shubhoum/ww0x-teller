{"version":3,"file":"static/js/49.f8ee6b3c.chunk.js","mappings":"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","sources":["../node_modules/alchemy-sdk/src/internal/request-batcher.ts","../node_modules/alchemy-sdk/src/api/alchemy-provider.ts","../node_modules/alchemy-sdk/src/internal/websocket-backfiller.ts","../node_modules/alchemy-sdk/src/api/alchemy-websocket-provider.ts","../node_modules/es5-ext/global.js","../node_modules/sturdy-websocket/src/index.ts","../node_modules/websocket/lib/browser.js","../node_modules/websocket/lib/version.js"],"sourcesContent":["import { JsonRpcRequest, JsonRpcResponse } from './internal-types';\n\n/** Maximum size of a batch on the rpc provider. */\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n\n/** Timeout interval before the pending batch is sent. */\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n\n/**\n * Internal class to enqueue requests and automatically send/process batches.\n *\n * The underlying batching mechanism is loosely based on ethers.js's\n * `JsonRpcBatchProvider`.\n *\n * @internal\n */\nexport class RequestBatcher {\n  /** Timeout timer that periodically sends the pending batch. */\n  private pendingBatchTimer: NodeJS.Timer | undefined;\n\n  /**\n   * Array of enqueued requests along with the constructed promise handlers for\n   * each request.\n   */\n  private pendingBatch: Array<BatchRequest> = [];\n\n  constructor(\n    private readonly sendBatchFn: SendBatchFn,\n    private readonly maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE\n  ) {}\n\n  /**\n   * Enqueues the provided request. The batch is immediately sent if the maximum\n   * batch size is reached. Otherwise, the request is enqueued onto a batch that\n   * is sent after 10ms.\n   *\n   * Returns a promise that resolves with the result of the request.\n   */\n  async enqueueRequest(request: JsonRpcRequest): Promise<any> {\n    const inflightRequest: BatchRequest = {\n      request,\n      resolve: undefined,\n      reject: undefined\n    };\n\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n\n    this.pendingBatch.push(inflightRequest);\n\n    if (this.pendingBatch.length === this.maxBatchSize) {\n      // Send batch immediately if we are at the maximum batch size.\n      void this.sendBatchRequest();\n    } else if (!this.pendingBatchTimer) {\n      // Schedule batch for next event loop + short duration\n      this.pendingBatchTimer = setTimeout(\n        () => this.sendBatchRequest(),\n        DEFAULT_REQUEST_BATCH_DELAY_MS\n      );\n    }\n\n    return promise;\n  }\n\n  /**\n   * Sends the currently queued batches and resets the batch and timer. Processes\n   * the batched response results back to the original promises.\n   */\n  private async sendBatchRequest(): Promise<void> {\n    // Get the current batch and clear it, so new requests\n    // go into the next batch\n    const batch = this.pendingBatch;\n    this.pendingBatch = [];\n    if (this.pendingBatchTimer) {\n      clearTimeout(this.pendingBatchTimer);\n      this.pendingBatchTimer = undefined;\n    }\n\n    // Get the request as an array of requests\n    const request = batch.map(inflight => inflight.request);\n\n    return this.sendBatchFn(request).then(\n      result => {\n        // For each result, feed it to the correct Promise, depending\n        // on whether it was a success or error\n        batch.forEach((inflightRequest, index) => {\n          const payload = result[index];\n          if (payload.error) {\n            const error = new Error(payload.error.message);\n            (error as any).code = payload.error.code;\n            (error as any).data = payload.error.data;\n            inflightRequest.reject!(error);\n          } else {\n            inflightRequest.resolve!(payload.result);\n          }\n        });\n      },\n      error => {\n        batch.forEach(inflightRequest => {\n          inflightRequest.reject!(error);\n        });\n      }\n    );\n  }\n}\n\n/** Function type to match the `fetchJson` function in ethers. */\ntype SendBatchFn = (reqs: JsonRpcRequest[]) => Promise<JsonRpcResponse[]>;\n\n/**\n * Internal interface to represent a request on a batch along with the promises to resolve it.\n */\ninterface BatchRequest {\n  request: JsonRpcRequest;\n  resolve?: (result: any) => void;\n  reject?: (error: Error) => void;\n}\n","import {\n  Network as NetworkFromEthers,\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { deepCopy } from '@ethersproject/properties';\nimport {\n  CommunityResourcable,\n  JsonRpcProvider\n} from '@ethersproject/providers';\nimport { ConnectionInfo, fetchJson } from '@ethersproject/web';\n\nimport { JsonRpcRequest, JsonRpcResponse } from '../internal/internal-types';\nimport { RequestBatcher } from '../internal/request-batcher';\nimport { Network } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_NETWORK,\n  EthersNetwork,\n  getAlchemyHttpUrl,\n  getAlchemyWsUrl\n} from '../util/const';\nimport { logWarn } from '../util/logger';\nimport { IS_BROWSER } from '../util/util';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\n *\n * @public\n */\nexport class AlchemyProvider\n  extends JsonRpcProvider\n  implements CommunityResourcable\n{\n  readonly apiKey: string;\n  readonly maxRetries: number;\n  readonly batchRequests: boolean;\n\n  /**\n   * VISIBLE ONLY FOR TESTING\n   *@internal\n   */\n  readonly batcher: RequestBatcher;\n\n  /** @internal */\n  constructor(config: AlchemyConfig) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    let connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'http'\n    );\n\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n\n    connection.throttleLimit = config.maxRetries;\n\n    // Add user provided overrides if they exist.\n    if (config.connectionInfoOverrides) {\n      connection = {\n        ...connection,\n        ...config.connectionInfoOverrides\n      };\n    }\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n\n    this.apiKey = config.apiKey;\n    this.maxRetries = config.maxRetries;\n    this.batchRequests = config.batchRequests;\n\n    // TODO: support individual headers when calling batch\n    const batcherConnection = {\n      ...this.connection,\n      headers: {\n        ...this.connection.headers,\n        'Alchemy-Ethers-Sdk-Method': 'batchSend'\n      }\n    };\n    const sendBatchFn = (\n      requests: JsonRpcRequest[]\n    ): Promise<JsonRpcResponse[]> => {\n      return fetchJson(batcherConnection, JSON.stringify(requests));\n    };\n    this.batcher = new RequestBatcher(sendBatchFn);\n\n    this.modifyFormatter();\n  }\n\n  /**\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\n   * ethers.js. Returns the API key for an Alchemy provider.\n   *\n   * @internal\n   * @override\n   */\n  static getApiKey(apiKey: any): string {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(\n        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`\n      );\n    }\n    return apiKey;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Converts the `Networkish` input to the network enum used by Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyNetwork(network?: Networkish): Network {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n\n    if (typeof network === 'number') {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be a string.`\n      );\n    }\n\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network as Network);\n    if (!isValidNetwork) {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be one of: ` +\n          `${Object.values(Network).join(', ')}.`\n      );\n    }\n    return network as Network;\n  }\n\n  /**\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\n   * the correct URLs for Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyConnectionInfo(\n    network: Network,\n    apiKey: string,\n    type: 'wss' | 'http'\n  ): ConnectionInfo {\n    const url =\n      type === 'http'\n        ? getAlchemyHttpUrl(network, apiKey)\n        : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: IS_BROWSER\n        ? {\n            'Alchemy-Ethers-Sdk-Version': VERSION\n          }\n        : {\n            'Alchemy-Ethers-Sdk-Version': VERSION,\n            'Accept-Encoding': 'gzip'\n          },\n      allowGzip: true,\n      url\n    };\n  }\n\n  /**\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\n   * method is called when calling methods on the parent class `BaseProvider`.\n   *\n   * @override\n   */\n  async detectNetwork(): Promise<NetworkFromEthers> {\n    let network = this.network;\n    if (network == null) {\n      network = await super.detectNetwork();\n\n      if (!network) {\n        throw new Error('No network detected');\n      }\n    }\n    return network;\n  }\n\n  _startPending(): void {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\n   * logic for sending requests to Alchemy.\n   *\n   * @param method The method name to use for the request.\n   * @param params The parameters to use for the request.\n   * @override\n   * @public\n   */\n  // TODO: Add headers for `perform()` override.\n  send(method: string, params: Array<any>): Promise<any> {\n    return this._send(method, params, 'send');\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `JsonRpcProvider.send()`.\n   *\n   * This method is copied over directly in order to implement custom headers\n   *\n   * @internal\n   */\n  _send(\n    method: string,\n    params: Array<any>,\n    methodName: string,\n    forceBatch = false\n  ): Promise<any> {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0'\n    };\n\n    // START MODIFIED CODE\n    const connection = { ...this.connection };\n    connection.headers!['Alchemy-Ethers-Sdk-Method'] = methodName;\n\n    if (this.batchRequests || forceBatch) {\n      return this.batcher.enqueueRequest(request as JsonRpcRequest);\n    }\n    // END MODIFIED CODE\n\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this\n    });\n\n    // We can expand this in the future to any call, but for now these\n    // are the biggest wins and do not require any serializing parameters.\n    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n    if (cache && this._cache[method]) {\n      return this._cache[method];\n    }\n\n    const result = fetchJson(\n      this.connection,\n      JSON.stringify(request),\n      getResult\n    ).then(\n      result => {\n        this.emit('debug', {\n          action: 'response',\n          request,\n          response: result,\n          provider: this\n        });\n\n        return result;\n      },\n      error => {\n        this.emit('debug', {\n          action: 'response',\n          error,\n          request,\n          provider: this\n        });\n\n        throw error;\n      }\n    );\n\n    // Cache the fetch, but clear it on the next event loop\n    if (cache) {\n      this._cache[method] = result;\n      setTimeout(() => {\n        // @ts-ignore - This is done by ethers.\n        this._cache[method] = null;\n      }, 0);\n    }\n\n    return result;\n  }\n\n  /**\n   * Overrides the base `Formatter` class inherited from ethers to support\n   * returning custom fields in Ethers response types.\n   *\n   * For context, ethers has a `Formatter` class that is used to format the\n   * response from a JSON-RPC request. Any fields that are not defined in the\n   * `Formatter` class are removed from the returned response. By modifying the\n   * `Formatter` class in this method, we can add support for fields that are\n   * not defined in ethers.\n   */\n  private modifyFormatter(): void {\n    this.formatter.formats['receiptLog']['removed'] = val => {\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      return undefined;\n    };\n  }\n}\n\n/**\n * DO NOT MODIFY.\n *\n * Original code copied over from ether.js's\n * `@ethersproject/web/src.ts/index.ts`. Used to support\n * {@link AlchemyProvider._send}, which is also copied over.\n */\nfunction getResult(payload: {\n  error?: { code?: number; data?: any; message?: string };\n  result?: any;\n}): any {\n  if (payload.error) {\n    const error: any = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n","import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: handle errors\n    const blockHeads = await this.provider.sendBatch(batchParts);\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    return this.sendBatchConcurrently(payload);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          const { result } = (message as SubscriptionEvent<unknown>).params;\n          this.emitEvent(virtualId, result);\n        }\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n\n  private emitEvent<T>(virtualId: string, result: T): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<unknown[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["RequestBatcher","sendBatchFn","maxBatchSize","arguments","length","undefined","_classCallCheck","pendingBatch","_createClass","key","value","request","inflightRequest","resolve","reject","promise","Promise","this","push","sendBatchRequest","pendingBatchTimer","setTimeout","_this","_context","abrupt","stop","_callee","batch","clearTimeout","map","inflight","_context2","then","result","forEach","index","payload","error","Error","message","code","data","_callee2","AlchemyProvider","_JsonRpcProvider","_inherits","_super2","_createSuper","config","_this2","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","url","throttleLimit","maxRetries","connectionInfoOverrides","Object","assign","ethersNetwork","EthersNetwork","call","batchRequests","batcherConnection","headers","batcher","requests","fetchJson","JSON","stringify","modifyFormatter","_this3","_context3","next","_super","detectNetwork","sent","_callee3","logWarn","DEFAULT_ALCHEMY_API_KEY","method","params","_send","methodName","_this4","forceBatch","id","_nextId","jsonrpc","enqueueRequest","emit","action","deepCopy","provider","cache","indexOf","_cache","getResult","response","formatter","formats","val","concat","CustomNetworks","getNetwork","DEFAULT_NETWORK","values","Network","includes","join","type","getAlchemyHttpUrl","getAlchemyWsUrl","IS_BROWSER","VERSION","allowGzip","JsonRpcProvider","WebsocketBackfiller","maxBackfillBlocks","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","getBlockNumber","toBlockNumber","getHeadEventsInRange","Math","max","lastSeenBlockNumber","fromHex","number","minBlockNumber","getReorgHeads","reorgHeads","intermediateHeads","_toConsumableArray","filter","previousLogs","getLogsInRange","blockNumber","getCommonAncestor","commonAncestor","removedLogs","log","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","newMax","send","blockNumberHex","toBlockExclusive","_context4","batchParts","i","toHex","sendBatch","blockHeads","toNewHeadsEvent","_callee4","_context5","oldEvent","getBlockByNumber","blockHead","hash","reverse","_callee5","_context6","_callee6","_context7","oldLog","blockHash","_callee7","_context8","rangeFilter","fromBlock","toBlock","_callee8","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","items","getKey","keysSeen","Set","item","has","add","CANCELLED","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","_WebSocketProvider","wsConstructor","protocol","ws","SturdyWebSocket","_a","process","versions","node","require","WebSocket","_events","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","parse","Array","isArray","isResponse","isSubscriptionEvent","physicalId","subscription","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","emitEvent","handleReopen","clear","_makeCancelToken","cancelled","cancel","makeCancelToken","cancelBackfill","_step","_iterator","_createForOfIteratorHelper","_loop","__awaiter","_assertThisInitialized","_regeneratorRuntime","mark","_callee9","wrap","_context9","prev","resubscribeAndBackfill","t0","console","s","n","done","err","e","f","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","noop","eventName","listener","_addEventListener","isAlchemyEvent","_off","_get","_getPrototypeOf","prototype","_removeAllListeners","_listenerCount","_listeners","once","verifyAlchemyEventName","EthersEvent","getAlchemyEventTag","_startEvent","ALCHEMY_EVENT_TYPES","customStartEvent","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","_context10","all","subId","resolvedParams","set","sentEvents","_subs","_callee10","_get2","_len","args","_key","stopped","eventTag","apply","_stopEvent","parts","nextId","_ref","_context11","sendBatchConcurrently","_callee11","removeSocketListeners","listenerCount","_websocket","addEventListener","removeEventListener","_context12","withBackoffRetries","withTimeout","_this5","getNewHeadsBackfill","backfillEvents","emitNewHeadsEvent","getLogsBackfill","emitLogsEvent","finish","_callee12","emitGenericEvent","emitProcessFn","emitFunction","_this6","setInterval","_callee13","_context13","reconnect","req","_this7","_context14","_callee14","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","fromAddress","toAddress","hashesOnly","_subscribe","AlchemySubscription","PENDING_TRANSACTIONS","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","_this8","BigNumber","from","toNumber","_emitted","block","filterLog","_this9","removeAllListeners","found","_this10","WebSocketProvider","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","retryCount","shouldRetry","nextWaitTime","_context15","delay","min","_callee15","ms","race","_","currentBlockNumber","firstGoodIndex","findIndex","splice","naiveFallback","self","window","module","exports","globalThis","defineProperty","configurable","__global__","protocolsOrOptions","options","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","listeners","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","close","reason","disposeSocket","shutdown","readyState","handleClose","dispatchEvent","dispatchEventOfType","l","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","slice","callListener","defaultPrevented","handleEvent","debug","DEFAULT_OPTIONS","POSITIVE_INFINITY","keys","_globalThis","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","prop"],"sourceRoot":""}